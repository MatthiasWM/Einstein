本家との相違点など
------------------


　○本家との相違点など

　　・文字列は 1 Byte（ASCII）コード

　　　※日本語対応はたぶん ShiftJIS, EUC, UTF-8 で行うことになると思う

　　・型指定の int, array と関数定義の native キーワードは無視されます
　　・リテラルはリードオンリーです。副作用がある操作は Clone して使う
　　　必要があります（パッケージと同じ扱い）

　○独自拡張

　　・ファイル先頭の # は１行目をコメント扱い（#! 実行に対応）

　　・NIL とは別に #UNBIND という内部状態（特殊即値）を追加。いまのところ
　　　#UNBIND は構文上では入力方法がありません。動作上は NIL と同じよう
　　　に扱われます

　　・== 演算子の追加

　　　= 演算子よりも強い比較を行いします

　　・不定長引数のサポート

　　　例：　 func(a1, a2, args...)
　　　３点リーダーのある args に残りの引数が配列として束縛されます。

　　・名前付マジックポインタの追加

　　　@name 形式のマジックポインタ（名前付マジックポインタ：Named Magic
　　　Pointer）を使用できるようにしました。

　　　Newton オリジナルのマジックポインタ（@1 形式）とは併用できません。
　　　互換性のため 　"NewtConf.h" で __NAMED_MAGIC_POINTER__ を
　　　コメントアウトすることにより Newton オリジナルのマジックポインタの使用
　　　を選択することができます。

　　・マジックポインタの定義構文を追加

　　　@name := {a: 1, b: 2};		// 名前付マジックポインタ
　　　@1 := {a: 1, b: 2};		// Newton オリジナルのマジックポインタ

　　・バイナリオブジェクト表現の追加

　　　本家ではバイナリオブジェクトを直接記述することはできませんでしたが、
　　　次の構文でバイナリオブジェクトを直接記述することをできるようにしま
　　　した

         <#class: n1, n2, ....>
         <# n1, n2, ....>

　　　※ n1, n2, ... は数値（１０進数、１６進数）

　　・32bit 符号付き整数のサポート

　　・正規表現オブジェクト表現を追加

　　　/正規表現のパターン/オプション
　　　例： /[a-zA-Z]+/im

　　上記の正規表現は実行時に {_proto: @protoREGEX, pattern: "[a-zA-Z]+", option: "im"}
　　として展開されます。

　　重要：実際に正規表現の機能を使用するには拡張ライブラリ protoREGEX が必要です。
　　　　　　　　その機能は拡張ライブラリに依存します。

　○その他

　　本家 NewtonScript の関数オブジェクトをダンプして

      fn := '{
               class: CodeBlock,
               instructions: <#instructions: 0x27, 0x00, 0x08, 0xA8, 0x70, 0x02>,
               literals: [literals: a],
               argFrame: {_nextArgFrame: NIL, _parent: NIL, _implementor: NIL},
               numArgs: 0
             };

      call fn with ();

　　と表現することにより、本家 NewtonScript のバイトコードを実行することが
　　できます。
